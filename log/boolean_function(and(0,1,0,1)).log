- - - - - - - - - - - - - - - time: 0 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> in_{3}: 1

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> in_{2}: <0/0>
>> in_{3}: <1/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <0/0>
>> 3,1: <0/0>
>> 3,2: <0/0>
>> 3,3: <0/0>
>> 3,4: <0/0>
>> 3,5: <0/0>
>> 3,6: <0/0>
>> 3,7: <0/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: []

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> in_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> in_{2}: <0/0>
>> in_{3}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <0/0>
>> 3,1: <0/0>
>> 3,2: <0/0>
>> 3,3: <0/0>
>> 3,4: <0/0>
>> 3,5: <0/0>
>> 3,6: <0/0>
>> 3,7: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0]

- - - - - - - - - - - - - - - time: 1 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> in_{3}: 1
>> 1,0: 1
>> 1,1: 1
>> 3,0: 1
>> 3,1: 1
>> 3,2: 1
>> 3,3: 1
>> 3,4: 1
>> 3,5: 1
>> 3,6: 1
>> 3,7: 1
>> aux_{0}: 1
>> aux_{1}: 1
>> aux_{2}: 1

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> in_{2}: <0/0>
>> in_{3}: <1/0>
>> 0,0: <0/0>
>> 1,0: <1/0>
>> 1,1: <1/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <1/0>
>> 3,1: <1/0>
>> 3,2: <1/0>
>> 3,3: <1/0>
>> 3,4: <1/0>
>> 3,5: <1/0>
>> 3,6: <1/0>
>> 3,7: <1/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <1/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0]

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> in_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,2: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,3: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,4: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,5: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,6: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,7: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{2}: Rule(regex='^a$', consumed=1, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> in_{2}: <0/0>
>> in_{3}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <0/0>
>> 3,1: <0/0>
>> 3,2: <0/0>
>> 3,3: <0/0>
>> 3,4: <0/0>
>> 3,5: <0/0>
>> 3,6: <0/0>
>> 3,7: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0, 0]

- - - - - - - - - - - - - - - time: 2 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> in_{3}: 1
>> 1,0: 1
>> 1,1: 1
>> 3,0: 1
>> 3,1: 1
>> 3,2: 1
>> 3,3: 1
>> 3,4: 1
>> 3,5: 1
>> 3,6: 1
>> 3,7: 1
>> aux_{0}: 1
>> aux_{1}: 1
>> aux_{2}: 1
>> aux_{3}: 1
>> out: 10

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> in_{2}: <0/0>
>> in_{3}: <1/0>
>> 0,0: <0/0>
>> 1,0: <1/0>
>> 1,1: <1/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <1/0>
>> 3,1: <1/0>
>> 3,2: <1/0>
>> 3,3: <1/0>
>> 3,4: <1/0>
>> 3,5: <1/0>
>> 3,6: <1/0>
>> 3,7: <1/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <1/0>
>> aux_{3}: <1/0>
>> out: <10/0>
>> env_{out}: [0, 0]

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> in_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,2: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,3: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,4: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,5: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,6: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,7: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{2}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> out: Rule(regex='^a{10}$', consumed=10, produced=0, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> in_{2}: <0/0>
>> in_{3}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <0/0>
>> 3,1: <0/0>
>> 3,2: <0/0>
>> 3,3: <0/0>
>> 3,4: <0/0>
>> 3,5: <0/0>
>> 3,6: <0/0>
>> 3,7: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0, 0, 0]

- - - - - - - - - - - - - - - time: 3 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> in_{3}: 1
>> 1,0: 1
>> 1,1: 1
>> 3,0: 1
>> 3,1: 1
>> 3,2: 1
>> 3,3: 1
>> 3,4: 1
>> 3,5: 1
>> 3,6: 1
>> 3,7: 1
>> aux_{0}: 1
>> aux_{1}: 1
>> aux_{2}: 1
>> aux_{3}: 1
>> out: 11

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> in_{2}: <0/0>
>> in_{3}: <1/0>
>> 0,0: <0/0>
>> 1,0: <1/0>
>> 1,1: <1/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <1/0>
>> 3,1: <1/0>
>> 3,2: <1/0>
>> 3,3: <1/0>
>> 3,4: <1/0>
>> 3,5: <1/0>
>> 3,6: <1/0>
>> 3,7: <1/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <1/0>
>> aux_{3}: <1/0>
>> out: <11/0>
>> env_{out}: [0, 0, 0]

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> in_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,2: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,3: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,4: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,5: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,6: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 3,7: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{2}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> out: Rule(regex='^a{11}$', consumed=11, produced=0, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> env_{in_{2}}: [0, 0, 0, 0, 0]
>> env_{in_{3}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> in_{2}: <0/0>
>> in_{3}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> 2,0: <0/0>
>> 2,1: <0/0>
>> 2,2: <0/0>
>> 2,3: <0/0>
>> 3,0: <0/0>
>> 3,1: <0/0>
>> 3,2: <0/0>
>> 3,3: <0/0>
>> 3,4: <0/0>
>> 3,5: <0/0>
>> 3,6: <0/0>
>> 3,7: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0, 0, 0, 0]

