- - - - - - - - - - - - - - - time: 0 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> no events during phase 1

> phase 2: showing starting state

>> L_{i}: <2/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <280/0>

> phase 3: selecting rules

>> L_{i}: Rule(regex='^a{2}$', consumed=2, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <280/0>

- - - - - - - - - - - - - - - time: 1 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> L_{i,1}: 1
>> L_{i,2}: 1
>> r: 1

> phase 2: showing starting state

>> L_{i}: <0/0>
>> L_{i,1}: <1/0>
>> L_{i,2}: <1/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <281/0>

> phase 3: selecting rules

>> L_{i,1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> L_{i,2}: Rule(regex='^a$', consumed=1, produced=1, delay=1)
>> r: Rule(regex='^a(aa)+$', consumed=3, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <278/0>

- - - - - - - - - - - - - - - time: 2 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> L_{j}: 2
>> L_{k}: 1

> phase 2: showing starting state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <2/0>
>> L_{k}: <1/0>
>> r: <278/0>

> phase 3: selecting rules

>> L_{j}: Rule(regex='^a{2}$', consumed=2, produced=1, delay=0)
>> L_{k}: Rule(regex='^a$', consumed=1, produced=0, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <278/0>

- - - - - - - - - - - - - - - time: 3 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> L_{k}: 1

> phase 2: showing starting state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <1/0>
>> r: <278/0>

> phase 3: selecting rules

>> L_{k}: Rule(regex='^a$', consumed=1, produced=0, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <278/0>

- - - - - - - - - - - - - - - time: 4 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> no events during phase 1

> phase 2: showing starting state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <278/0>

> phase 3: selecting rules

>> no events during phase 3

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> L_{i}: <0/0>
>> L_{i,1}: <0/0>
>> L_{i,2}: <0/0>
>> L_{j}: <0/0>
>> L_{k}: <0/0>
>> r: <278/0>

