- - - - - - - - - - - - - - - time: 0 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: []

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0]

- - - - - - - - - - - - - - - time: 1 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> 1,0: 1
>> 1,1: 1
>> aux_{0}: 1
>> aux_{1}: 1
>> aux_{2}: 1

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> 0,0: <0/0>
>> 1,0: <1/0>
>> 1,1: <1/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <1/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0]

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{2}: Rule(regex='^a$', consumed=1, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0, 0]

- - - - - - - - - - - - - - - time: 2 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> 1,0: 1
>> 1,1: 1
>> aux_{0}: 1
>> aux_{1}: 1
>> aux_{2}: 1
>> aux_{3}: 1
>> out: 2

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> 0,0: <0/0>
>> 1,0: <1/0>
>> 1,1: <1/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <1/0>
>> aux_{3}: <1/0>
>> out: <2/0>
>> env_{out}: [0, 0]

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{2}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> out: Rule(regex='^a{2}$', consumed=2, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0, 0, 1]

- - - - - - - - - - - - - - - time: 3 - - - - - - - - - - - - - - - 

> phase 1: incoming spikes

>> in_{1}: 1
>> 1,0: 1
>> 1,1: 1
>> aux_{0}: 1
>> aux_{1}: 1
>> aux_{2}: 1
>> aux_{3}: 1
>> out: 3

> phase 2: showing starting state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <1/0>
>> 0,0: <0/0>
>> 1,0: <1/0>
>> 1,1: <1/0>
>> aux_{0}: <1/0>
>> aux_{1}: <1/0>
>> aux_{2}: <1/0>
>> aux_{3}: <1/0>
>> out: <3/0>
>> env_{out}: [0, 0, 1]

> phase 3: selecting rules

>> in_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,0: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> 1,1: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{0}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{1}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{2}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> aux_{3}: Rule(regex='^a$', consumed=1, produced=1, delay=0)
>> out: Rule(regex='^a{3}$', consumed=3, produced=1, delay=0)

> phase 4: accumulating updates, detecting outputs

>> no events during phase 4

> phase 5: showing in-between state

>> env_{in_{0}}: [0, 0, 0, 0, 0]
>> env_{in_{1}}: [1, 1, 1, 1, 1]
>> in_{0}: <0/0>
>> in_{1}: <0/0>
>> 0,0: <0/0>
>> 1,0: <0/0>
>> 1,1: <0/0>
>> aux_{0}: <0/0>
>> aux_{1}: <0/0>
>> aux_{2}: <0/0>
>> aux_{3}: <0/0>
>> out: <0/0>
>> env_{out}: [0, 0, 1, 1]

